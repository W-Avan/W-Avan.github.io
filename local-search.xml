<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IDEA常用快捷键</title>
    <link href="/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><table><thead><tr><th>快捷键</th><th align="left">功能</th></tr></thead><tbody><tr><td><code>Alt + Enter</code></td><td align="left">导入包，自动修正代码</td></tr><tr><td><code>Ctrl + Y</code></td><td align="left">删除光标所在行</td></tr><tr><td><code>Ctrl + D</code></td><td align="left">复制光标所在行的内容，插入光标位置下面</td></tr><tr><td><code>Ctrl + Alt + L</code></td><td align="left">格式化代码</td></tr><tr><td><code>Ctrl + /</code></td><td align="left">单行注释，再按取消注释</td></tr><tr><td><code>Ctrl + Shift + /</code></td><td align="left">选中代码注释，多行注释，再按取消注释</td></tr><tr><td><code>Alt + Ins</code></td><td align="left">自动生成代码， toString，Get，set等方法</td></tr><tr><td><code>Alt + Shift + 上下箭头</code></td><td align="left">移动当前代码行</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>41.缺失的第一个正数</title>
    <link href="/2020/06/27/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2020/06/27/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。   </p><p><strong>提示：</strong>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。  </p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>若不考虑时空复杂度，可以使用辅助空间记录出现的数字的方式实现，亦或者从<code>1</code>开始暴力比较每一个数组元素来实现。而按照题目中的要求，则需要尝试利用题目所给出的数组空间来协助完成。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><h5 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h5><p>考虑<code>n</code>个元素的整数数组，未出现的最小的正整数只可能在<code>[1, n+1]</code>。若<code>n</code>个元素存放了<code>[1,n]</code>的所有整数，则最小未出现的正数未<code>n+1</code>；否则，最小未出现的正数一定在<code>[1, n]</code>之间。我们使用负数来标记当前元素对应的下标的值存在。  </p><p>首先，先将原始数组中的负数全部变为<code>n+1</code>，因为若出现负数，则最小未出现正数一定不是<code>n+1</code>。全部变成正数后，就不会影响后面的标记操作。在遍历时，每次取当前元素的绝对值（这样我们既可以进行取负值标记，同时也保证了不破坏当前元素的原始值），若绝对值<code>x</code>在<code>[1, n]</code>之间，则将下标为<code>x-1</code>的元素值取反，表示<code>x</code>出现过。再进行一遍遍历，若当前下标<code>i</code>的元素值不为<code>i+1</code>则返回<code>i+1</code>；若均等于，则返回<code>n+1</code>。  </p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; num : nums)&#123;            <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;                num = n+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);            <span class="hljs-keyword">if</span>(num &lt;= n)&#123;                nums[num<span class="hljs-number">-1</span>] = -<span class="hljs-built_in">abs</span>(nums[num<span class="hljs-number">-1</span>]);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(n)，<code>n</code>为数组的长度。  </li><li>空间复杂度： O(1)。  </li></ul><h5 id="方法二：置换"><a href="#方法二：置换" class="headerlink" title="方法二：置换"></a>方法二：置换</h5><p>除了打标记，我们可以尝试将值为<code>x</code>的元素归位下标<code>x-1</code>。举个例子<code>[3, 4, -1, 1]</code>，归位后的数组应为<code>[1, -1, 3, 4]</code>，如此，我们就可以知道缺少的位置。  </p><p>对于<code>x = nums[i]</code>，若<code>x∈[1, n]</code>，则交换<code>nums[i]</code>和<code>nums[x-1]</code>的值。但是注意，若<code>nums[i] = x = nums[x-1]</code>则会陷入死循环，此时说明<code>x</code>已经位于正确的位置了，所以可以跳出循环，开始遍历下一个数。  </p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;                swap(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><h5 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(n)，<code>n</code>为数组的长度。  </li><li>空间复杂度： O(1)。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
