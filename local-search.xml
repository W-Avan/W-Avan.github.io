<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>反射案例</title>
    <link href="/2020/11/27/%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B/"/>
    <url>/2020/11/27/%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>需求：写一个“框架，可以帮我们创建任意类的对象，并执行其中任意方法。</li><li>实现：<ul><li>配置文件</li><li>反射</li></ul></li><li>步骤：<ul><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ul></li></ul><p>首先定义配置文件<code>pro.properties</code>：</p><pre><code class="hljs properties"><span class="hljs-attr">className</span>=<span class="hljs-string">com.domain.Student</span><span class="hljs-attr">methodName</span>=<span class="hljs-string">sleep</span></code></pre><p>定义两种测试类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;sleep...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;eat...&quot;</span>);    &#125;&#125;</code></pre><p>定义反射测试类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 1.加载配置文件</span>        <span class="hljs-comment">// 1.1创建Properties对象</span>        Properties pro = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-comment">// 1.2加载配置文件，转换为一个集合</span>        <span class="hljs-comment">// 1.2.1获取class目录下的配置文件</span>        ClassLoader classLoader = ReflectTest.class.getClassLoader();        InputStream is = classLoader.getResourceAsStream(<span class="hljs-string">&quot;pro.properties&quot;</span>);        pro.load(is);        String className = pro.getProperty(<span class="hljs-string">&quot;className&quot;</span>);        String methodName = pro.getProperty(<span class="hljs-string">&quot;methodName&quot;</span>);        Class cls = Class.forName(className);        Object o = cls.getDeclaredConstructor().newInstance();        Method method = cls.getMethod(methodName);        method.invoke(o);    &#125;&#125;</code></pre><p>若想创建<code>Person</code>对象且执行<code>eat()</code>方法，无需修改具体的代码实现部分，仅需修改配置文件<code>pro.properties</code>为：</p><pre><code class="hljs properties"><span class="hljs-attr">className</span>=<span class="hljs-string">com.domain.Person</span><span class="hljs-attr">methodName</span>=<span class="hljs-string">eat</span></code></pre><p>如果所写的系统十分庞大，修改java代码后，需要重新测试，重新编译，重新上线等等。但是配置文件仅仅只是一个物理文件，修改方便，且让程序的扩展性更强。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口的内容小结</title>
    <link href="/2020/10/18/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/10/18/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Java 9+版本中，接口的内容可以有：</p><p><strong>1. 成员变量其实是常量，格式：</strong></p><p>[public]&nbsp; [static]&nbsp; [final]&nbsp; 数据类型&nbsp; 常量名称&nbsp; =&nbsp; 数据值；</p><p><strong>注意：</strong></p><p>&emsp;常量必须进行赋值，而且一旦赋值不能改变。</p><p>&nbsp; &nbsp; 常量名称完全大写，用下划线进行分隔。</p><p><strong>2. 接口中最重要的就是抽象方法，格式：</strong></p><p>[public]&nbsp; [abstract]&nbsp; 返回值类型 方法名称(参数列表);</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; 实现类必须覆盖重写接口所有的抽象方法，除非实现类时抽象类。</p><p><strong>3. 从Java 8开始，接口里允许定义默认方法，格式：</strong></p><p>[public]&nbsp; <strong>default</strong> 返回值类型 方法名称(参数列表) { 方法体 }</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; 默认方法也可以被覆盖重写</p><p><strong>4.从Java 8开始，接口里允许定义静态方法，格式：</strong></p><p>[public] <strong>static</strong> 返回值类型 方法名称(参数列表) { 方法体 }</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; 应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p><p><strong>5.从Java 9开始，接口里允许定义私有方法，格式：</strong></p><p>普通私有方法： private 返回值类型 方法名称(参数列表) { 方法体 }</p><p>静态私有方法： private static 返回值类型 方法名称(参数列表) { 方法体}</p><p><strong>注意：</strong></p><p>&nbsp; &nbsp; private的方法只有接口自己才能调用，不能被实现类或别人使用。</p><h4 id="使用接口的时候，需要注意："><a href="#使用接口的时候，需要注意：" class="headerlink" title="使用接口的时候，需要注意："></a>使用接口的时候，需要注意：</h4><ol><li>接口是没有静态代码块或者构造方法的。</li><li>一个类的直接父类是唯一的，但是一个类可以同时实现<strong>多个</strong>接口。</li></ol><p>格式：</p><p>public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {</p><p>&emsp; // 覆盖重写所有抽象方法</p><p>}</p><ol start="3"><li>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</li><li>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</li><li>如果实现类所实现的多个接口当中，存在重复的<strong>默认方法</strong>，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果直接父类当中的方法，和接口当中的<strong>默认方法</strong>产生了冲突，优先用父类当中的方法。</li></ol><h4 id="接口的多继承："><a href="#接口的多继承：" class="headerlink" title="接口的多继承："></a>接口的多继承：</h4><ol><li>类与类之间是<strong>单继承</strong>的。直接父类只有一个。</li><li>类与接口之间是多实现的。一个类可以实现多个接口。</li><li>接口与接口之间是<strong>多继承</strong>的。</li></ol><p><strong>注意事项：</strong></p><ol><li>多个父接口当中的抽象方法如果重复，没关系。</li><li>多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，<strong>【而且带着default关键字】</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>super和this关键字图解</title>
    <link href="/2020/10/16/super%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%BE%E8%A7%A3/"/>
    <url>/2020/10/16/super%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%BE%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20201016161306.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>super</tag>
      
      <tag>this</tag>
      
      <tag>内存图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父子类构造方法的访问特点</title>
    <link href="/2020/10/16/%E7%88%B6%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/"/>
    <url>/2020/10/16/%E7%88%B6%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>在继承关系中，父子类构造方法的访问特点：</p><ol><li>子类构造方法当中有一个默认隐含的 <em>“super()”</em> 调用，所以一定是先调用的父类构造，后执行的子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造。</li><li>super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li></ol><p>总结：</p><p>​    子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fu</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;父类无参构造执行&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;父类有参构造执行&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Zi</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        super();    // 在调用父类无参构造方法</span>        <span class="hljs-keyword">super</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 在调用父类重载的构造方法</span>        System.out.println(<span class="hljs-string">&quot;子类构造方法执行&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        super();  // 错误写法！只有子类构造方法，才能调用父类构造方法。</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Constructor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Zi zi = <span class="hljs-keyword">new</span> Zi();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>构造方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中方法的覆盖重写</title>
    <link href="/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99/"/>
    <url>/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h3 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h3><p>概念：在继承关系中，方法的名称一样，参数列表<strong>也一样</strong>。建议使用覆盖、覆写的叫法，不易混淆。</p><h4 id="重写与重载的区别："><a href="#重写与重载的区别：" class="headerlink" title="重写与重载的区别："></a>重写与重载的区别：</h4><ul><li>重写（Override）：方法的名称一样，参数列表<strong>也一样</strong>。覆盖、覆写。</li><li>重载（Overload）：方法的名称一样，参数列表<strong>不一样</strong>。详情请见<a href="https://w-avan.github.io/2020/07/22/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/">方法重载</a></li></ul><h4 id="方法覆盖重写的注意事项："><a href="#方法覆盖重写的注意事项：" class="headerlink" title="方法覆盖重写的注意事项："></a>方法覆盖重写的注意事项：</h4><ol><li><p>必须保证父子类之间的方法名称相同，参数列表也相同。</p><p>@Override：写在方法前面，用来检测是不是有效的正确覆盖方法。</p><p>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</p></li><li><p>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围。</p><p>小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</p></li><li><p>子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符。</p><p>小扩展提示：public &gt; protected &gt; (default) &gt; private</p><p>备注：（default）不是关键字default，而是什么都不写，留空。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>Override</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中成员变量的访问特点</title>
    <link href="/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/"/>
    <url>/2020/10/14/%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>当类之间产生了关系后，其中各类中的成员变量，有产生了哪些影响呢？</p><h4 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h4><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。</p><h4 id="成员变量重名时"><a href="#成员变量重名时" class="headerlink" title="成员变量重名时"></a>成员变量重名时</h4><p>创建子类对象时，访问有两种方式：</p><ul><li><p>直接通过子类对象访问成员变量：</p><p>等号左边是谁，就优先用谁，没有则向上找。</p></li><li><p>间接通过成员方法访问成员变量：</p><p>该方法属于谁，就优先用谁，没有则向上找。</p></li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-keyword">int</span> numFu = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">100</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodFu</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(num);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span></span>&#123;    <span class="hljs-keyword">int</span> numZi = <span class="hljs-number">20</span>;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">200</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodZi</span><span class="hljs-params">()</span></span>&#123;        System.out.println(num);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01ExtendsField</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Fu fu = <span class="hljs-keyword">new</span> Fu();        System.out.println(fu.numFu);   <span class="hljs-comment">// 10</span>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);        Zi zi = <span class="hljs-keyword">new</span> Zi();        System.out.println(zi.numFu);   <span class="hljs-comment">// 10</span>        System.out.println(zi.numZi);   <span class="hljs-comment">// 20</span>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);        <span class="hljs-comment">// 等号左边是谁，就优先用谁</span>        System.out.println(zi.num);     <span class="hljs-comment">// 优先子类， 200</span><span class="hljs-comment">//        System.out.println(zi.abc);   // 到处都没有，编译报错！</span>        System.out.println(<span class="hljs-string">&quot;================&quot;</span>);        <span class="hljs-comment">// 这个方法是子类的，优先用子类的，没有再向上找</span>        zi.methodZi();  <span class="hljs-comment">// 200</span>        <span class="hljs-comment">// 这个方法是在父类中定义的，</span>        zi.methodFu();  <span class="hljs-comment">// 100</span>    &#125;&#125;</code></pre><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要用<code>super</code>关键字，修饰父类成员变量，类似于之前学过的<code>this</code>。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;    <span class="hljs-comment">// Zi中的成员变量</span>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">6</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 访问父类中的num</span>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-keyword">super</span>.num);        <span class="hljs-comment">// 访问子类中的num</span>        System.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-keyword">this</span>.num);    &#125;&#125;</code></pre><p>小贴士：Fu类中的成员变量是<strong>非私有的</strong>，子类中可以直接访问。若Fu类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？可以在父类中提供公共的getXxx方法和setXxx方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>成员变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K-近邻算法</title>
    <link href="/2020/10/09/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2020/10/09/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>​        简单地说，k-近邻算法采用测量不同特征值之间的距离方法进行分类。</p><ul><li><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>存在一个样本数据集合，也称为训练样本集，并且样本集中每个数据都存在标签。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p></li><li><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>精度高、对异常值不敏感、无数据输入假定。</p></li><li><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>计算复杂度高、空间复杂度高。</p></li><li><h3 id="适用数据范围："><a href="#适用数据范围：" class="headerlink" title="适用数据范围："></a>适用数据范围：</h3><p>数值型和标称型。</p></li><li><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3></li></ul><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*</span><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> operator<span class="hljs-keyword">import</span> matplotlib<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> listdir<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createDataSet</span>():</span>    group = array([[<span class="hljs-number">1.0</span>, <span class="hljs-number">1.1</span>], [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>]])    labels = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]    <span class="hljs-keyword">return</span> group, labels<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify0</span>(<span class="hljs-params">inX, dataSet, labels, k</span>):</span>    dataSetSize = dataSet.shape[<span class="hljs-number">0</span>]    diffMat = tile(inX, (dataSetSize,<span class="hljs-number">1</span>),) - dataSet <span class="hljs-comment"># tile：获得dataSetSize行1列的 inX向量（横着）</span>    sqDiffMat = diffMat**<span class="hljs-number">2</span>    sqDistances = sqDiffMat.sum(axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># axis=1：将一个矩阵的每一行向量内部相加</span>    distances = sqDistances**<span class="hljs-number">0.5</span>    sortedDistIndicies = distances.argsort()  <span class="hljs-comment"># argsort() 返回数组值从小到大的索引值</span>    classCount = &#123;&#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):        votelabel = labels[sortedDistIndicies[i]]        classCount[votelabel] = classCount.get(votelabel, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)    <span class="hljs-keyword">return</span> sortedClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<span class="hljs-comment"># 将文本记录解析为为 训练样本矩阵，类标签向量</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file2matrix</span>(<span class="hljs-params">filename</span>):</span>    fr = open(filename)    arrayOfLines = fr.readlines()    <span class="hljs-comment"># 按行读</span>    numberOfLines = len(arrayOfLines)    returnMat = zeros((numberOfLines, <span class="hljs-number">3</span>))    classLabelVector = []    index = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> arrayOfLines:        line = line.strip() <span class="hljs-comment"># 截取掉所有的回车字符</span>        listFromLine = line.split(<span class="hljs-string">&#x27;\t&#x27;</span>)     <span class="hljs-comment"># 使用tab字符将整行数据分割成一个元素列表</span>        returnMat[index, :] = listFromLine[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]        classLabelVector.append(int(listFromLine[<span class="hljs-number">-1</span>]))        index += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> returnMat, classLabelVector<span class="hljs-comment"># datingDataMat, datingLables = file2matrix(&#x27;datingTestSet2.txt&#x27;)</span><span class="hljs-comment"># fig = plt.figure()</span><span class="hljs-comment"># ax = fig.add_subplot(111)</span><span class="hljs-comment"># ax.scatter(datingDataMat[:,0], datingDataMat[:,1], 15.0*array(datingLables), 15.0*array(datingLables))</span><span class="hljs-comment"># plt.show()</span><span class="hljs-comment"># 归一化特征值</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">autoNorm</span>(<span class="hljs-params">dataSet</span>):</span>    minVals = dataSet.min(<span class="hljs-number">0</span>)    <span class="hljs-comment"># min(0)返回该矩阵中每一列的最小值 / min(1)返回该矩阵中每一行的最小值</span>    maxVals = dataSet.max(<span class="hljs-number">0</span>)    ranges = maxVals - minVals    normDataSet = zeros(shape(dataSet))    m = dataSet.shape[<span class="hljs-number">0</span>]    normDataSet = dataSet - tile(minVals, (m,<span class="hljs-number">1</span>))    normDataSet = normDataSet / tile(ranges, (m,<span class="hljs-number">1</span>))    <span class="hljs-keyword">return</span> normDataSet, ranges, minVals<span class="hljs-comment"># normMat, ranges, minVals = autoNorm(datingDataMat)</span><span class="hljs-comment"># 测试集的错误率</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">datingClassTest</span>():</span>    hoRatio = <span class="hljs-number">0.10</span>    datingDataMat, datingLables = file2matrix(<span class="hljs-string">&#x27;datingTestSet2.txt&#x27;</span>)    normMat, ranges, minVals = autoNorm(datingDataMat)    m = normMat.shape[<span class="hljs-number">0</span>]    numTestVecs = int(m*hoRatio)    errorCount = <span class="hljs-number">0.0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(numTestVecs):        classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], datingLables[numTestVecs:m], <span class="hljs-number">3</span>)        print(<span class="hljs-string">&quot;the classifier came back with: %d, the real answer is: %d&quot;</span> % (classifierResult, datingLables[i]))        <span class="hljs-keyword">if</span>(classifierResult != datingLables[i]): errorCount += <span class="hljs-number">1.0</span>    print(<span class="hljs-string">&quot;the total error rate is: %f&quot;</span> % (errorCount/float(numTestVecs)))<span class="hljs-comment"># 预测具体的人</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classifyPerson</span>():</span>    resultList = [<span class="hljs-string">&#x27;not at all&#x27;</span>, <span class="hljs-string">&#x27;in small doses&#x27;</span>, <span class="hljs-string">&#x27;in large doses&#x27;</span>]    percentTats = float(input(<span class="hljs-string">&quot;percentage of time spent playing video games?&quot;</span>))    ffMiles = float(input(<span class="hljs-string">&quot;frequent flier miles earned per year?&quot;</span>))    iceCream = float(input(<span class="hljs-string">&quot;liters of ice cream consumed per year?&quot;</span>))    datingDataMat, datingLables = file2matrix(<span class="hljs-string">&quot;datingTestSet2.txt&quot;</span>)    normMat, ranges, minVals = autoNorm(datingDataMat)    inArr = array([percentTats, ffMiles, iceCream])    classifierResult = classify0((inArr-minVals)/ranges, normMat,datingLables,<span class="hljs-number">3</span>)    print(<span class="hljs-string">&quot;You will probably like this person: &quot;</span>, resultList[classifierResult<span class="hljs-number">-1</span>])<span class="hljs-comment"># 准备数据（将32*32的二进制图像矩阵转换为1*1024的向量）</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">img2vector</span>(<span class="hljs-params">filename</span>):</span>    returnVect = zeros((<span class="hljs-number">1</span>, <span class="hljs-number">1024</span>))    fr = open(filename)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>):        lineStr = fr.readline()        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>):            returnVect[<span class="hljs-number">0</span>, <span class="hljs-number">32</span>*i+j] = int(lineStr[j])    <span class="hljs-keyword">return</span> returnVect<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handwritingClassTest</span>():</span>    hwLabels = []   <span class="hljs-comment"># 标签集</span>    trainingFileList = listdir(<span class="hljs-string">&#x27;trainingDigits&#x27;</span>)    <span class="hljs-comment"># 列出给定目录下的文件名</span>    m = len(trainingFileList)    trainingMat = zeros((m, <span class="hljs-number">1024</span>))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):        fileNameStr = trainingFileList[i]   <span class="hljs-comment"># 文件名 如&#x27;9_45.txt&#x27;,数字9的第45个实例</span>        fileStr = fileNameStr.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment"># &#x27;9_45&#x27;</span>        classNumStr = int(fileStr.split(<span class="hljs-string">&#x27;_&#x27;</span>)[<span class="hljs-number">0</span>])   <span class="hljs-comment"># 9</span>        hwLabels.append(classNumStr)        trainingMat[i,:] = img2vector(<span class="hljs-string">&#x27;trainingDigits/%s&#x27;</span> % fileNameStr)    testFileList = listdir(<span class="hljs-string">&#x27;testDigits&#x27;</span>)    errorCount = <span class="hljs-number">0.0</span>    mTest = len(testFileList)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(mTest):        fileNameStr = testFileList[i]        fileStr = fileNameStr.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]        classNumStr = int(fileStr.split(<span class="hljs-string">&#x27;_&#x27;</span>)[<span class="hljs-number">0</span>])        vectorUnderTest = img2vector(<span class="hljs-string">&#x27;testDigits/%s&#x27;</span> % fileNameStr)        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="hljs-number">3</span>)        print(<span class="hljs-string">&quot;the classifier came back with: %d, the real answer is: %d&quot;</span> % (classifierResult, classNumStr))        <span class="hljs-keyword">if</span>(classifierResult != classNumStr):    errorCount += <span class="hljs-number">1.0</span>    print(<span class="hljs-string">&quot;\nthe total number of errors is: %d&quot;</span> % errorCount)    print(<span class="hljs-string">&quot;\nthe total error rate is: %f&quot;</span> % (errorCount/float(mTest)))</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分类算法</tag>
      
      <tag>有监督学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris树遍历算法</title>
    <link href="/2020/09/24/Morris%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/24/Morris%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文主要解决一个问题，如何实现二叉树的前中后序遍历，并满足以下要求：</p><ul><li>空间复杂度为O(1)；</li><li>二叉树的形状不能被破坏（中间过程允许改变其形状）。</li></ul><p>通常情况下，我们使用递归和迭代的方式进行遍历。但是由于这两种方式会用到递归栈或用户自定义栈等，空间复杂度为O(n)，均不满足上述要求。</p><p><strong>Morris Traversal</strong>方法可以满足上述两个要求，只需要O(1)的空间复杂度，同时在O(n)时间复杂度内完成遍历。</p><h4 id="一、中序遍历"><a href="#一、中序遍历" class="headerlink" title="一、中序遍历"></a>一、中序遍历</h4><p>我们在中序遍历的时候，一定先遍历左子树，然后遍历当前节点，最后遍历右子树。我们需要一种巧妙地方法可以在O(1)的空间下，遍历完左子树后可以再回到当前节点。我们希望当前节点在遍历完当前节点的前驱之后被遍历，我们可以考虑修改前驱的right指针。当前节点的前驱节点的right指针可能本来就指向当前节点（前驱是当前节点的父节点），也可能是当前节点左子树最右下的节点。如果是后者，我们希望遍历完这个前驱节点后再回到当前节点，可以将它的right指针指向当前节点。</p><p>Morris中序遍历的一个重要步骤就是寻找当前节点的前驱节点，并且Morris中序遍历寻找下一个点始终是通过转移到right指针指向的位置来完成的。</p><ul><li>如果当前节点没有左子树，则遍历这个点，然后跳转到当前节点的右子树。</li><li>如果当前节点有左子树，那么它的前驱节点一定在左子树上，我们可以在左子树上一直向右行走，找到当前点的前驱节点。<ul><li>如果前驱节点没有右子树，就将前驱节点的right指针指向当前节点。这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点。</li><li>如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并修改了right指针，这个时候我们重新将前驱的右孩子设置为空，遍历当前节点，然后跳转到当前节点的右子树。</li></ul></li></ul><p>我们可以得到这样的代码框架：</p><pre><code class="hljs c++">Treenode* cur = root, *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">while</span> (cur) &#123;    <span class="hljs-keyword">if</span> (!cur-&gt;left) &#123;        <span class="hljs-comment">// ...遍历cur</span>        cur = cur-&gt;right;        <span class="hljs-keyword">continue</span>;    &#125;        pre = cur-&gt;left;    <span class="hljs-keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) &#123;        pre = pre-&gt;right;    &#125;        <span class="hljs-keyword">if</span> (!pre-&gt;right) &#123;        pre-&gt;right = cur;        cur = cur-&gt;left;    &#125;    <span class="hljs-keyword">if</span> (pre-&gt;right == cur) &#123;        pre-&gt;right = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">// ...遍历cur</span>        cur = cur-&gt;right;       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList集合</title>
    <link href="/2020/08/12/ArrayList%E9%9B%86%E5%90%88/"/>
    <url>/2020/08/12/ArrayList%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList当中的常用方法有："><a href="#ArrayList当中的常用方法有：" class="headerlink" title="ArrayList当中的常用方法有："></a>ArrayList当中的常用方法有：</h3><ul><li><code>public boolean add(E e)</code>：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。  </li></ul><p><strong>备注：</strong>对于<em>ArrayList</em>集合来说，<em>add</em>添加动作一定是成功的，所以返回值可用可不用。 （但对于其他集合来说，<em>add</em>添加动作不一定成功）。  </p><ul><li><code>public E get(int index)</code>：从集合当中获取元素，参数是索引编号（从0开始），返回值就是对应位置的元素。  </li><li><code>public E remove(int index)</code>：从集合当中删除元素，参数是索引编号（从0开始），返回值就是被删除的元素。</li><li><code>public int size()</code>：获取集合的尺寸长度，返回值是集合中包含的元素个数。  </li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03ArrayListMethod</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        System.out.println(list);   <span class="hljs-comment">// []</span>        <span class="hljs-comment">// 向集合中添加元素: add</span>        <span class="hljs-keyword">boolean</span> success = list.add(<span class="hljs-string">&quot;aaa&quot;</span>);        System.out.println(list);   <span class="hljs-comment">// [aaa]</span>        System.out.println(<span class="hljs-string">&quot;添加的动作是否成功： &quot;</span> + success);    <span class="hljs-comment">// true</span>        list.add(<span class="hljs-string">&quot;bbb&quot;</span>);        list.add(<span class="hljs-string">&quot;ccc&quot;</span>);        list.add(<span class="hljs-string">&quot;ddd&quot;</span>);        list.add(<span class="hljs-string">&quot;eee&quot;</span>);        System.out.println(list);   <span class="hljs-comment">// [aaa, bbb, ccc, ddd, eee]</span>        <span class="hljs-comment">// 从集合中获取元素： get。 索引值从0开始</span>        String name = list.get(<span class="hljs-number">2</span>);        System.out.println(<span class="hljs-string">&quot;第2号索引位置： &quot;</span> + name);  <span class="hljs-comment">// ccc</span>        <span class="hljs-comment">// 从集合中删除元素： remove。 索引值从0开始</span>        String whoRemoved = list.remove(<span class="hljs-number">3</span>);        System.out.println(<span class="hljs-string">&quot;被删除的人是： &quot;</span> + whoRemoved);    <span class="hljs-comment">// ddd</span>        System.out.println(list);   <span class="hljs-comment">// [aaa, bbb, ccc, eee]</span>        <span class="hljs-comment">// 获取集合的长度尺寸，也就是其中元素的个数</span>        <span class="hljs-keyword">int</span> size = list.size();        System.out.println(<span class="hljs-string">&quot;集合的长度是： &quot;</span> + size);    &#125;&#125;</code></pre><h3 id="ArrayList集合存储基本数据："><a href="#ArrayList集合存储基本数据：" class="headerlink" title="ArrayList集合存储基本数据："></a>ArrayList集合存储基本数据：</h3><p>如果希望集合<em>ArrayList</em>当中存储基本类型数据，必须使用基本类型对应的“包装类”。  </p><table><thead><tr><th align="center">基本类型</th><th align="center">包装类（引用类型，包装类都位于java.lang包下）</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><p>从JDK 1.5+开始，支持自动装箱、自动拆箱。</p><ul><li>自动装箱：基本类型 ——&gt; 包装类型</li><li>自动拆箱：包装类型 ——&gt; 基本类型</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05ArrayListBasic</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ArrayList&lt;String&gt; listA = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 错误写法！ 泛型只能是引用类型，不能是基本类型</span><span class="hljs-comment">//        ArrayList&lt;int&gt; listB = new ArrayList&lt;int&gt;();</span>        ArrayList&lt;Integer&gt; listC = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        listC.add(<span class="hljs-number">100</span>);        listC.add(<span class="hljs-number">200</span>);        System.out.println(listC);  <span class="hljs-comment">// [100, 200]</span>        <span class="hljs-keyword">int</span> num = listC.get(<span class="hljs-number">1</span>);        System.out.println(num);    <span class="hljs-comment">// 200</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定义一个标准的类</title>
    <link href="/2020/08/11/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB/"/>
    <url>/2020/08/11/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>一个标准的类通常要拥有下面四个组成部分：</p><ol><li>所有的成员变量都要使用<code>private</code>关键字修饰</li><li>为每一个成员变量编写一对<em>Getter/Setter</em>方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员变量与局部变量的区别</title>
    <link href="/2020/08/03/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/08/03/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="局部变量和成员变量"><a href="#局部变量和成员变量" class="headerlink" title="局部变量和成员变量"></a>局部变量和成员变量</h3><ol><li>定义的位置不一样<strong>【重点】</strong> </li></ol><p>&emsp;局部变量：在方法的内部  </p><p>&emsp;成员变量：在方法的外部，直接写在类当中  </p><ol start="2"><li>作用范围不一样<strong>【重点】</strong>  </li></ol><p>&emsp;局部变量：只有方法当中才可以使用，出了方法就不能再用  </p><p>&emsp;成员变量：整个类全都可以通用  </p><ol start="3"><li>默认值不一样<strong>【重点】</strong>  </li></ol><p>&emsp;局部变量：没有默认值，如果要使用，必须手动进行赋值  </p><p>&emsp;成员变量：如果没有赋值，会有默认值，规则和数组一样  </p><ol start="4"><li>内存的位置不一样（了解）  </li></ol><p>&emsp;局部变量：位于栈内存  </p><p>&emsp;成员变量：位于堆内存  </p><ol start="5"><li>生命周期不一样（了解）  </li></ol><p>&emsp;局部变量：随着方法进栈而诞生，随着方法出栈而消失  </p><p>&emsp;成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失  </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01VariableDifference</span> </span>&#123;    String name;    <span class="hljs-comment">// 成员变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 局部变量</span>        System.out.println(num);        System.out.println(name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> param)</span> </span>&#123;    <span class="hljs-comment">// 方法的参数就是局部变量</span>        <span class="hljs-comment">// 参数在方法调用的时候，必然会被赋值的</span>        System.out.println(param);        <span class="hljs-keyword">int</span> age;    <span class="hljs-comment">// 局部变量</span><span class="hljs-comment">//        System.out.println(age);    // 没赋值不能用，会报错</span><span class="hljs-comment">//        System.out.println(num);    // 错误写法 e</span>        System.out.println(name);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的内存划分</title>
    <link href="/2020/07/23/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <url>/2020/07/23/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Java的内存需要划分成为5个部分："><a href="#Java的内存需要划分成为5个部分：" class="headerlink" title="Java的内存需要划分成为5个部分："></a>Java的内存需要划分成为5个部分：</h3><ol><li><p><strong>栈（stack）：</strong>存放的是方法中的局部变量。<font color = "red">方法的运行一定要在栈当中运行。</font>  </p></li><li><p><strong>堆（Heap）：</strong><font color = "red">凡是<code>new</code>出来的东西，都在堆当中。</font>    </p><p>&emsp; &emsp; 堆内存里面的东西都有一个地址值：16进制      </p><p>&emsp; &emsp; 堆内存里面的数据，都有默认值。规则：  </p></li></ol><a id="more"></a><table><thead><tr><th align="center">数据类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">如果是整数</td><td align="center">默认为0</td></tr><tr><td align="center">如果是浮点数</td><td align="center">默认为0.0</td></tr><tr><td align="center">如果是字符</td><td align="center">默认为’\u0000’</td></tr><tr><td align="center">如果是布尔</td><td align="center">默认为false</td></tr><tr><td align="center">如果是引用类型</td><td align="center">默认为null</td></tr></tbody></table><ol start="3"><li><strong>方法区（Method Area）：</strong>存储<code>.class</code>相关信息，包含方法的信息。  </li><li>本地方法栈（Native Method Stack）：与操作系统相关。   </li><li>寄存器（pc Register）：与<code>CPU</code>相关。    </li></ol><h3 id="一个数组的内存图示例："><a href="#一个数组的内存图示例：" class="headerlink" title="一个数组的内存图示例："></a>一个数组的内存图示例：</h3><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200723224304.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法重载</title>
    <link href="/2020/07/22/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    <url>/2020/07/22/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名，太麻烦。  </p><p><strong>方法的重载（overload）：</strong>多个方法的名称一样，但是<strong>参数列表</strong>不一样。  </p><p>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。  </p><h4 id="方法的重载与下列因素相关："><a href="#方法的重载与下列因素相关：" class="headerlink" title="方法的重载与下列因素相关："></a>方法的重载与下列因素相关：</h4><ol><li>参数个数不同  </li><li>参数类型不同  </li><li>参数的多类型顺序不同</li></ol><h4 id="方法的重载与下列因素无关："><a href="#方法的重载与下列因素无关：" class="headerlink" title="方法的重载与下列因素无关："></a>方法的重载与下列因素无关：</h4><ol><li>与参数的名称无关</li><li>与参数的返回值类型无关  </li></ol><a id="more"></a><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));  <span class="hljs-comment">// 30</span>        System.out.println(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>));  <span class="hljs-comment">// 60</span>        System.out.println(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>));  <span class="hljs-comment">// 100</span>    &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">double</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (a + b);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (a + b);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;  <span class="hljs-comment">/*   错误写法！！ 与方法的返回值类型无关</span><span class="hljs-comment">    public static double sum(int a, int b) &#123;</span><span class="hljs-comment">return a + b + 0.0;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    */</span>  <span class="hljs-comment">/*   错误写法！！ 与参数的名称无关</span><span class="hljs-comment">    public static int sum(int x, int y) &#123;</span><span class="hljs-comment">        return x + y;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b + c;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b + c + d;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA常用快捷键</title>
    <link href="/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><table><thead><tr><th>快捷键</th><th align="left">功能</th></tr></thead><tbody><tr><td><code>Alt + Enter</code></td><td align="left">导入包，自动修正代码</td></tr><tr><td><code>Ctrl + Y</code></td><td align="left">删除光标所在行</td></tr><tr><td><code>Ctrl + D</code></td><td align="left">复制光标所在行的内容，插入光标位置下面</td></tr><tr><td><code>Ctrl + Alt + L</code></td><td align="left">格式化代码</td></tr><tr><td><code>Ctrl + /</code></td><td align="left">单行注释，再按取消注释</td></tr><tr><td><code>Ctrl + Shift + /</code></td><td align="left">选中代码注释，多行注释，再按取消注释</td></tr><tr><td><code>Alt + Ins</code></td><td align="left">自动生成代码， toString，Get，set等方法</td></tr><tr><td><code>Alt + Shift + 上下箭头</code></td><td align="left">移动当前代码行</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找算法</title>
    <link href="/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="二分查找的思想"><a href="#二分查找的思想" class="headerlink" title="二分查找的思想"></a>二分查找的思想</h3><p>减而治之，即将大规模问题转化成小规模问题。减而治之是分而治之的特例，将大问题划分成若干个子问题以后，最终答案只在其中一个子问题里。  </p><h3 id="二分查找的基本问题（二分查找模板一）"><a href="#二分查找的基本问题（二分查找模板一）" class="headerlink" title="二分查找的基本问题（二分查找模板一）"></a>二分查找的基本问题（二分查找模板一）</h3><a id="more"></a><p>[LeetCode] 第704题：<a href="https://leetcode-cn.com/problems/binary-search/">二分查找</a>  </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == target)<span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)left = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>right = mid - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre><p>说明：</p><ol><li>循环可以继续的条件是<code>while(left &lt;= right)</code>， 表示当<code>left==right</code>成立时，还有一个元素，即下标<code>left(right)</code>位置的元素还没有看到，需要继续查看这个元素的值，看看是不是目标元素；</li><li>关于取中间数<code>int mid = (left + right) / 2;</code>在<code>left + right</code>很大的时候会发生整型溢出，一般这样改写：  </li></ol><p><code>int mid = left + (right - left) / 2;</code></p><p>这两种写法事实上没有太大区别，在<code>left</code>和<code>right</code>都表示数组下标的时候，几乎不会越界，因为绝大多是情况下不会开那么长的数组。  </p><p>这里不建议把<code>/2</code>改写成<code>&gt;&gt;1</code>，理由是**高级语言在编译期间会做优化，会将<code>2</code>，以及除以2的方幂的操作，在内部修改为<code>&gt;&gt;</code>**，工程师只需要写程序本来的逻辑就好了。如果使用位运算，在C++中可能还需要注意运算优先级的问题。  </p><ol start="3"><li>还有一个细节，<code>/2</code>表示的是下取整，当数组中的元素个数为偶数的时候，<code>int mid = left + (right - left) / 2;</code>只能取到位于左边的那个元素。取右边中间数的表达式是（其实就是在括号里+1，表示上取整）：<code>int mid = left + (right - left) / 2;</code>  </li></ol><p>以上代码可以认为是二分查找的模板一。  </p><h3 id="二分查找模板二（在循环体里排除不存在目标元素的区间）"><a href="#二分查找模板二（在循环体里排除不存在目标元素的区间）" class="headerlink" title="二分查找模板二（在循环体里排除不存在目标元素的区间）"></a>二分查找模板二（在循环体里排除不存在目标元素的区间）</h3><p>说明：这个模板的难点在于<strong>理解根据分支决定取中间数是上取整还是下取整，以避免死循环。</strong>  </p><p>我们上面有提到过，上取整还是下取整理应同样对待，但是在这个模板里为了避免死循环就有所区分。这一点理解清楚以后，解决二分查找问题就不会很难了。  </p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从考虑哪些元素一定不是目标元素开始考虑：<strong>根据看到的<code>mid</code>位置的元素，排除掉一定不可能存在目标元素的区间，而下一轮在可能存在目标的子区间里继续查找。</strong>  </p><h4 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h4><ol><li>先把循环可以继续的条件携程<code>while(left &lt; right)</code>，表示退出循环的时候，<code>[left, right]</code>这个区间里只有一个元素，这个元素<strong>有可能</strong>就是目标元素；  </li><li>写<code>if</code>和<code>else</code>语句时，思考当<code>nums[mid]</code>满足什么性质的时候，<code>nums[mid]</code>不是解，进而接着判断<code>mid</code>的左边有没有可能是解，<code>mid</code>的右边有没有可能是解；</li></ol><h4 id="理解如何避免死循环（重难点）"><a href="#理解如何避免死循环（重难点）" class="headerlink" title="理解如何避免死循环（重难点）"></a>理解如何避免死循环（重难点）</h4><p>根据<code>mid</code>被分到左边区间还是右边区间，代码写出来只有以下2种：  </p><p><strong>边界收缩行为1：</strong><code>mid</code>被分到左边。即区间被分成<code>[left, mid]</code>于<code>[mid+1, right]</code>，这里用[闭区间]表示区间端点可以取到，下同；  </p><p>代码写出来是这样的：  </p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (check(mid)) &#123;<span class="hljs-comment">// 下一轮搜索区间是 [mid+1, right]</span>left = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;right = mid;&#125;</code></pre><p><strong>边界收缩行为2：</strong><code>mid</code>被分到右边。即区间被分成<code>[left, mid - 1]</code>与<code>[mid, right]</code>;</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (check(mid)) &#123;    right = mid - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> &#123;left = mid;&#125;</code></pre><p>面对上面的<strong>边界收缩行为2</strong>（<code>mid</code>被分到右边），在待搜索区间收缩到只剩下2个元素的时候，<strong>就有可能造成死循环。搜索区间不能缩小，是造成死循环的原因</strong>。  </p><p>有了上面的分析，我们把上面 [边界收缩行为] 对应的中间数取法补上：    </p><p><strong>边界收缩行为1：</strong><code>mid</code>被分到左边。即区间被分成<code>[left, mid]</code>与<code>[mid + 1, right]</code>，此时取中间数的时候下取整。  </p><pre><code class="hljs vbscript"><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(check(<span class="hljs-built_in">mid</span>)) &#123;<span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;&#125;</code></pre><p><strong>边界收缩行为2：</strong><code>mid</code>被分到右边。即区间被分为<code>[left, mid - 1]</code>与<code>[mid, right]</code>，此时取中间数的时候<strong>上取整</strong>。  </p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (check(mid)) &#123;right = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;left = mid;&#125;</code></pre><p>规则：<strong>在<code>if</code> <code>else</code>语句里面只要出现<code>left = mid</code>的时候，把取中间数行为改成上取整即可</strong>。    </p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法——归并排序</title>
    <link href="/2020/07/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>设归并排序的当前区间为<code>R[low...high]</code>，分治法的三个步骤是：  </p><ul><li>分解：将当前区间一分为二，即求分裂点  </li><li>求解：递归地对两个子区间<code>R[low...mid]</code>和<code>R[mid+1...high]</code>进行归并排序  </li><li>组合：将已排序的两个子区间<code>R[low...mid]</code>和<code>R[mid+1...high]</code>归并为一个有序的区间<code>R[low...high]</code>  </li></ul><p>递归的终结条件：子区间的长度为1  </p><a id="more"></a><h4 id="算法示意图："><a href="#算法示意图：" class="headerlink" title="算法示意图："></a>算法示意图：</h4><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200712235803.png"></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span></span>&#123;<span class="hljs-keyword">int</span> left_start = low, left_len = (high - low) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right_start = low + left_len;        <span class="hljs-keyword">int</span> cnt = low;        <span class="hljs-keyword">while</span>(left_start &lt; low + left_len &amp;&amp; right_start &lt; high + <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(nums[left_start] &lt; nums[right_start])result[cnt++] = nums[left_start++];            <span class="hljs-keyword">else</span>result[cnt++] = nums[right_start++];        &#125;        <span class="hljs-keyword">while</span>(left_start &lt; low + left_len)result[cnt++] = nums[left_start++];        <span class="hljs-keyword">while</span>(right_start &lt; high + <span class="hljs-number">1</span>)result[cnt++] = nums[right_start++];    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span></span>&#123;<span class="hljs-keyword">if</span>(low &lt; high)&#123;<span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;            mergeSort(nums, low, mid, result);            mergeSort(nums, mid+<span class="hljs-number">1</span>, high, result);            merge(nums, low, high, result);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++)nums[i] = result[i];        &#125;    &#125;&#125;;</code></pre><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li>时间复杂度：</li></ul><p>最差时间复杂度： O(nlogn)</p><p>平均时间复杂度：O(nlogn)</p><ul><li>空间复杂度：</li></ul><p>最差空间复杂度：O(n)</p><p>稳定性：稳定</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>经典排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法——快速排序</title>
    <link href="/2020/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>快速排序，<strong>即选定基准数据并找出其正确索引位置的过程</strong>。</p><p>通过使用<strong>分治思想</strong>对快速排序算法进行描述。下面对一个典型的子数组<code>nums[p...r]</code>进行快速排序的三步分治过程：  </p><p>&emsp; <strong>分解：</strong>数组<code>nums[p...r]</code>被划分为两个（可能为空）子数组<code>nums[p...q-1]</code>和<code>nums[q+1...r]</code>，使得<code>nums[p...q-1]</code>中的每个元素都小于<code>nums[q]</code>，而<code>nums[q+1...r]</code>中的每个元素都大于<code>nums[q]</code>。</p><p>&emsp; <strong>解决：</strong>通过递归调用快速排序，对数组<code>nums[p...q-1]</code>和<code>nums[q+1...r]</code>进行排序。</p><p>&emsp; <strong>合并：</strong>因为子数组都是原址排序的，所以不需要合并操作：数组<code>nums[p...r]</code>已经有序。</p><p>下面以一个实例来描述快速排序的过程。 </p><a id="more"></a><p>如下图所示，假设最开始的基准数据为数组第一个元素23，则首先用一个临时变量取存储基准数据，即tmp = 23；然后分别从数组的两端扫描数组，设两个指示标志：low指向起始位置，high指向末尾位置。</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708185112.png"></p><p>首先从<strong>后半部分</strong>开始比较，如果扫描到的值大于基准数据就让high-1，如果发现有元素比基准元素值小（如上图18&lt;=tmp），就将high位置的值赋值给low位置。</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708191132.png"></p><p><strong>然后开始从前往后扫描</strong>，如果扫描到的元素小于基准元素，则low+1；如果发现有元素大于基准元素的值(如上图46 &gt;= tmp)，就将low位置的值赋值给high位置。指针移动并且数据交换后的结果如下所示：</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708191511.png"></p><p>然后再开始从后往前扫描，原理同上，发现11 &lt;= tmp，则将high位置的值赋给low位置，结果如下：</p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708192100.png"></p><p>然后再从前往后扫描，直到<strong>low==high</strong>结束循环，此时low或者high的下标就是基准数据23在该数组中的正确索引位置，如下图所示：  </p><p><img src="https://raw.githubusercontent.com/W-Avan/picBed/master/20200708211026.png"></p><p>这样一遍走下来，就可以确定一个元素的位置，以后采用递归的方式，分别对前半部分和后半部分排序。</p><h4 id="几个要点："><a href="#几个要点：" class="headerlink" title="几个要点："></a>几个要点：</h4><ul><li>确定基准元素后，先从<code>high</code>向前开始比较。</li><li>在遍历比较时，判断是否满足<code>&gt;=</code>或<code>&lt;=</code>，即等于时不用交换。</li><li>循环结束的条件为<code>low&gt;=high</code>。循环结束后，需要将基准元素值写入当前的<code>low</code>或<code>high</code>位置。</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[low];<span class="hljs-comment">// 设置基准数据</span>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= tmp)high--;            nums[low] = nums[high];            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= tmp)low++;            nums[high] = nums[low];        &#125;        nums[low] = tmp;        <span class="hljs-keyword">return</span> low;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">if</span>(low &lt; high)&#123;<span class="hljs-keyword">int</span> mid = partition(nums, low, high);            quickSort(nums, low, mid<span class="hljs-number">-1</span>);            quickSort(nums, mid+<span class="hljs-number">1</span>, high);        &#125;    &#125;&#125;;</code></pre><h4 id="随机快速排序："><a href="#随机快速排序：" class="headerlink" title="随机快速排序："></a>随机快速排序：</h4><p>随机快排在确定基准元素时，采用一种随机抽样的随机化技术，使得从数组<code>nums[l...r]</code>中随机选取一个元素作为基准元素。由于基准元素的选取是随机的，舍得对输入数组的划分也是比较均衡的，从而获得较好的期望性能。  </p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[low];        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= tmp)high--;            nums[low] = nums[high];            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= tmp)low++;            nums[high] = nums[low];        &#125;        nums[low] = tmp;        <span class="hljs-keyword">return</span> low;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">random_partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-keyword">int</span> n = rand() % (high - low) + low;<span class="hljs-comment">// 随机选取下标</span>        swap(nums[low], nums[n]);<span class="hljs-comment">// 与low位置交换</span>        <span class="hljs-keyword">return</span> partition(nums, low, high);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-keyword">if</span>(low &lt; high)&#123;<span class="hljs-keyword">int</span> mid = random_partition(nums, low, high);            quickSort(nums, low, mid<span class="hljs-number">-1</span>);            quickSort(nums, mid+<span class="hljs-number">1</span>, high);        &#125;    &#125;&#125;;</code></pre><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p>时间复杂度：</p><p>考虑到最好情况，每次都是均匀划分，则时间复杂度为<code>O(nlgn)</code>。</p><p>但如果是最坏情况，比如[1,2,3,4,5]，复杂度变为<code>O(n^2)</code>。</p></li><li><p>空间复杂度：</p><p>这里分析就地快速排序的空间复杂度。首先就地快速排序使用的空间是<code>O(1)</code>的，也就是常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据。</p><p>最优的情况下空间复杂度为：<code>O(logn)</code>；每一次都平分数组的情况。</p><p>最差的情况下空间复杂度为：<code>O(n)</code>；退化为冒泡排序的情况。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>经典排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滚动数组</title>
    <link href="/2020/07/06/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"/>
    <url>/2020/07/06/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍一个十分实用的小技巧——滚动数组。它常被用来完成常数优化和减少代码量，且<strong>滚动数组思想</strong>是一种常见的动态规划优化方法。  </p><p>假设有如下状态转移方程：  </p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; dp[i][j] = max(dp[i-1][j+1], dp[i-1][j-1]);​</p><p>按照该状态转移方程，我们可以用二维数组保存其状态值，通过如下代码片段完成其状态的转移（这里仅做说明，不考虑边界情况）：  </p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);&#125;&#125;<span class="hljs-keyword">int</span> ans = dp[n][m];</code></pre><a id="more"></a><p>考虑到每次状态的转移仅与上一行有关（或以及本行已更新的部分），我们可以将二维数组优化到使用一维数组保存。如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;        buf[i] = <span class="hljs-built_in">max</span>(dp[j+<span class="hljs-number">1</span>], dp[j<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;dp[j] = buf[j];    &#125;&#125;<span class="hljs-keyword">int</span> ans = dp[m];</code></pre><p>如该代码片段所示，我们将原本二维的状态空间优化到了一维，对应的我们需要在每次状态转移过后进行依次循环次数为m的赋值操作。该操作不仅增加了代码量，还增加了程序的耗时。于是我们使用滚动数组，对其再次进行优化：  </p><p>定义大小为2*m的数组为其状态空间：  </p><p><code>int dp[2][m];</code>  </p><p>初始状态保存在dp[0][i]中。  </p><p>设定两个int类型指针  </p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *src; <span class="hljs-comment">//源指针</span><span class="hljs-keyword">int</span> *des; <span class="hljs-comment">//目的指针</span></code></pre><p>由于初始状态保存在dp数组的第0行中，初始时  </p><pre><code class="hljs c++">src = dp[<span class="hljs-number">1</span>];des = dp[<span class="hljs-number">0</span>];</code></pre><p>按照状态转移方程进行状态转移  </p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;swap(src, des); <span class="hljs-comment">//交换源指针和目的指针</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;des[j] = <span class="hljs-built_in">max</span>(src[j+<span class="hljs-number">1</span>], src[j<span class="hljs-number">-1</span>]);&#125;&#125;<span class="hljs-keyword">int</span> ans = des[m];</code></pre><p>如代码所示，我们在每次循环进行状态转移之前交换源数组和目的数组的指针，使程序能够正确的从源数组中转移状态到目的数组中。当状态转移完成时，新得到状态保存于目的数组中，但它在下一次循环的状态转移中又将变为源数组，于是我们在下次状态转移开始前再次交换源数组和目的数组指针，这就是滚动数组的工作原理。  </p><p>滚动数组这个技巧不仅优化了原始的状态空间，还减少了循环次数节约了程序运行时间，同时对代码量的缩减也有很好的效果，是一个值得学习的小技巧。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>41.缺失的第一个正数</title>
    <link href="/2020/06/27/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2020/06/27/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。   </p><p><strong>提示：</strong>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。  </p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>若不考虑时空复杂度，可以使用辅助空间记录出现的数字的方式实现，亦或者从<code>1</code>开始暴力比较每一个数组元素来实现。而按照题目中的要求，则需要尝试利用题目所给出的数组空间来协助完成。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><h5 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h5><p>考虑<code>n</code>个元素的整数数组，未出现的最小的正整数只可能在<code>[1, n+1]</code>。若<code>n</code>个元素存放了<code>[1,n]</code>的所有整数，则最小未出现的正数未<code>n+1</code>；否则，最小未出现的正数一定在<code>[1, n]</code>之间。我们使用负数来标记当前元素对应的下标的值存在。  </p><p>首先，先将原始数组中的负数全部变为<code>n+1</code>，因为若出现负数，则最小未出现正数一定不是<code>n+1</code>。全部变成正数后，就不会影响后面的标记操作。在遍历时，每次取当前元素的绝对值（这样我们既可以进行取负值标记，同时也保证了不破坏当前元素的原始值），若绝对值<code>x</code>在<code>[1, n]</code>之间，则将下标为<code>x-1</code>的元素值取反，表示<code>x</code>出现过。再进行一遍遍历，若当前下标<code>i</code>的元素值不为<code>i+1</code>则返回<code>i+1</code>；若均等于，则返回<code>n+1</code>。  </p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; num : nums)&#123;            <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">0</span>)&#123;                num = n+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);            <span class="hljs-keyword">if</span>(num &lt;= n)&#123;                nums[num<span class="hljs-number">-1</span>] = -<span class="hljs-built_in">abs</span>(nums[num<span class="hljs-number">-1</span>]);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(n)，<code>n</code>为数组的长度。  </li><li>空间复杂度： O(1)。  </li></ul><h5 id="方法二：置换"><a href="#方法二：置换" class="headerlink" title="方法二：置换"></a>方法二：置换</h5><p>除了打标记，我们可以尝试将值为<code>x</code>的元素归位下标<code>x-1</code>。举个例子<code>[3, 4, -1, 1]</code>，归位后的数组应为<code>[1, -1, 3, 4]</code>，如此，我们就可以知道缺少的位置。  </p><p>对于<code>x = nums[i]</code>，若<code>x∈[1, n]</code>，则交换<code>nums[i]</code>和<code>nums[x-1]</code>的值。但是注意，若<code>nums[i] = x = nums[x-1]</code>则会陷入死循环，此时说明<code>x</code>已经位于正确的位置了，所以可以跳出循环，开始遍历下一个数。  </p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;                swap(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><h5 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度：O(n)，<code>n</code>为数组的长度。  </li><li>空间复杂度： O(1)。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5441.保证文件名唯一</title>
    <link href="/2020/06/21/5441-%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80/"/>
    <url>/2020/06/21/5441-%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个长度为<code>n</code>的字符串数组<code>names</code>。你将会在文件系统中创建<code>n</code>个文件夹：在第<code>i</code>分钟，新建名为<code>names[i]</code>的文件夹。  </p><p>由于两个文件<strong>不能</strong>共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以<code>(k)</code>的形式为新文件夹的文件名添加后缀，其中<code>k</code>是能保证文件名唯一的<strong>最小正整数</strong>。  </p><p>返回长度为<code>n</code>的字符串数组，其中<code>ans[i]</code>是创建第<code>i</code>个文件夹时系统分配给该文件夹的实际名称。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>我们考虑使用一个<code>map</code>记录<code>&lt;当前文件名， 最小可用下标&gt;</code>，并用一个<code>vector</code>存储最终答案。先判断当前文件名是否出现过，如果未出现，则初始化<code>&lt;文件名， 1&gt;</code> 放入<code>map</code>中，同时，将对应文件名放入<code>vector</code>中；若当前文件名出现过，则从<code>map</code>中映射的最小可用下标开始向后枚举，得到第一个未被使用过的最小下标<code>i</code>，得到目标文件名<code>str</code>，存入答案数组中，并将<code>map</code>中对应文件名的最小可用下标更新至<code>i+1</code>，同时，将<code>&lt;str, 1&gt;</code>的映射关系存入<code>map</code>中。   </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">getFolderNames</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; names)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = names.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;  M;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-built_in">string</span> tmp = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">if</span>(M.<span class="hljs-built_in">find</span>(names[i]) == M.<span class="hljs-built_in">end</span>())&#123;                M[names[i]] = <span class="hljs-number">1</span>;                tmp = names[i];              &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">int</span> k = M[names[i]];                tmp =  names[i] + <span class="hljs-string">&#x27;(&#x27;</span> + to_string(k) + <span class="hljs-string">&#x27;)&#x27;</span>;                <span class="hljs-keyword">while</span>(M.<span class="hljs-built_in">find</span>(tmp) != M.<span class="hljs-built_in">end</span>())&#123;                    k++;                    tmp =  names[i] + <span class="hljs-string">&#x27;(&#x27;</span> + to_string(k) + <span class="hljs-string">&#x27;)&#x27;</span>;                &#125;                    M[names[i]] = k+<span class="hljs-number">1</span>;                M[tmp] = <span class="hljs-number">1</span>;            &#125;            res.push_back(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：只经过一遍数组元素的遍历，因此时间复杂度O(n)。  </li><li>空间复杂度： 创建了辅助空间<code>map</code>和<code>res</code>，因此空间复杂度O(n)。  </li></ul><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>起初对每个文件名的下标查找采用依次从1开始向后遍历，当一个文件名出现次数较多时，会有较多无用的搜索，从而导致了超时。因此，改进后采用记录当前可用的最小下标<code>i</code>，为了防止加上当前最小下标后的文件名在之前输入时已经出现过的情况，这里需要从此下标<code>i</code>开始向后寻找第一个没有使用过的下标。这样，可以避免每次都会重复访问<code>i</code>之前的下标，从而降低时间复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1014.最佳观光组合</title>
    <link href="/2020/06/17/1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/"/>
    <url>/2020/06/17/1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定正整数数组<code>A</code>，<code>A[i]</code>表示第<code>i</code>个观光景点的评分，并且两个景点<code>i</code>和<code>j</code>之间的距离为<code>j-i</code>。  </p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。  </p><p>返回一对观光景点能取得的最高分。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><h5 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h5><p>我们可以通过枚举任意两点之间的评分之和，然后取其中最高分，但是当数组元素较多时，会超时。  </p><h5 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h5><p>首先考虑如何优化上述遍历的双重循环问题，可以采用空间换时间的方法，通过一次遍历计算当前位置的最高分。  </p><p>我们观察得分公式为<code>A[i] + A[j] + i - j</code>，可以将其拆分成两部分<code>(A[i] + i) + (A[j] - j)</code>，先用两个数组预先保存对应下标<code>i</code>的<code>A[i] + i</code>和<code>A[i] - i</code>。接着进行一遍遍历，记录当前位置<code>j</code>之前的<code>A[i] + i</code>能得到的最大值，并与当前位置的<code>A[j] - j</code>相加，得到当前位置能取得的最大值，直到一遍遍历结束后，即可得到整体的最高分。下面展示状态转移方程：  </p><center>dp[j] = max(A[i] + i) + (A[j] - j)                  (i < j)</center><p><code>dp[j]</code>指在下标为j的位置可以得到的最高评分。  </p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">V1</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">V2</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            V1[i] = A[i] + i;            V2[i] = A[i] - i;         &#125;        <span class="hljs-keyword">int</span> x = V1[<span class="hljs-number">0</span>], ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            ans = <span class="hljs-built_in">max</span>(x + V2[i], ans);            x = <span class="hljs-built_in">max</span>(x, V1[i]);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：一遍元素的遍历，故时间复杂度为O(n)。  </li><li>空间复杂度：两个辅助空间<code>V1</code>和<code>V2</code>，故空间复杂度为O(n)。     </li></ul><h5 id="改进与优化"><a href="#改进与优化" class="headerlink" title="改进与优化"></a>改进与优化</h5><p>上述计算每个位置的最高得分，只与此前的最大<code>A[i] + i</code>以及当前位置的<code>A[j] - j</code>有关，因此，我们可以用两个变量来记录这两个值，从而减少了上述方法中辅助空间的使用。  </p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">int</span> x = A[<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            ans = <span class="hljs-built_in">max</span>(x + A[i] - i, ans);            x = <span class="hljs-built_in">max</span>(x, A[i] + i);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：一遍元素的遍历，故时间复杂度为O(n)。  </li><li>空间复杂度：常数个变量，故空间复杂度为O(1)。     </li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1477.找两个和为目标值且不重叠的子数组</title>
    <link href="/2020/06/15/1477-%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2020/06/15/1477-%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组<code>arr</code>和一个整数值<code>target</code>。  </p><p>请你在<code>arr</code>中找<strong>两个互不重叠的子数组</strong>且它们的和都等于<code>target</code>。可能会有多种方案，请你返回满足要求的两个子数组长度和的<strong>最小值</strong>。  </p><p>请返回满足要求的最小长度和，如多无法找到这样的两个子数组，请返回**-1**。  </p><a id="more"></a><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>如果存在多个以<code>i</code>下标结尾的子数组满足要求，则选择其中长度最短的那一个。因为如果一个较长的子数组可以作为答案中的一部分，换成一个较短的子数组，也同样成立，同时满足总和更短。（贪心的思想）  </p><ol><li><p>首先，使用一个<code>map</code>来记录<code>&lt;前缀和，结尾下标&gt;</code>的映射信息。一个<code>vector</code>记录当前下标之前满足要求的最短子数组长度。</p></li><li><p>利用<code>当前前缀和 - target</code>判断是否存在目标子数组区间。若存在，则得出对应子数组长度，并与当前位置之前的最短子数组长度比较，将较小值存入一个<code>vector</code>中；否则，则存入<code>0</code>。  </p></li><li><p>得到一个满足要求的最短子数组后，以该子数组的起始下标为结尾，搜索<code>vector</code>中是否存在满足要求的第二个子数组，若存在，则记录两子数组长度和，并与当前最短的两个子数组之和进行比较，取小。  </p></li><li><p>经过一轮遍历之后，输出结果。    </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSumOfLengths</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;       <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; M;<span class="hljs-comment">// 用于&lt;前缀和，结尾下标&gt;的映射</span>       <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;       <span class="hljs-keyword">int</span> ans = <span class="hljs-number">2e9</span>;       <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; len;<span class="hljs-comment">// 记录到每个位置，和为target的最短子数组的长度</span>       <span class="hljs-keyword">int</span> mi = <span class="hljs-number">0</span>;<span class="hljs-comment">// 当前满足和为target的最短子数组的长度</span>       M[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;           t += arr[i];           M[t] = i;           <span class="hljs-keyword">if</span>(M.count(t - target))&#123;               <span class="hljs-keyword">int</span> l = M[t-target];               <span class="hljs-keyword">int</span> x = i - l;               <span class="hljs-keyword">if</span>(mi == <span class="hljs-number">0</span>)  mi = x;               <span class="hljs-keyword">else</span> mi = <span class="hljs-built_in">min</span>(mi, x);               len.push_back(mi);               <span class="hljs-keyword">if</span>(l != <span class="hljs-number">-1</span> &amp;&amp; len[l] != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 不是第一个满足条件的子数组</span>   ans = <span class="hljs-built_in">min</span>(ans, len[l] + x);               &#125;           &#125;<span class="hljs-keyword">else</span>&#123;               len.push_back(mi);           &#125;       &#125;       <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">2e9</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;       <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：一轮循环遍历，时间复杂度为O(n)。  </p></li><li><p>空间复杂度：用于哈希映射的<code>map</code>，以及记录目标子数组长度的<code>vector</code>，故空间复杂度为O(n)。</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5437.不同整数的最少数目</title>
    <link href="/2020/06/14/5437-%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE/"/>
    <url>/2020/06/14/5437-%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组<code>arr</code>和一个整数<code>k</code>。现需要从数组中恰好移除<code>k</code>个元素，请找出移除后数组中不同整数的最少数目。  </p><h5 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h5><p>&emsp;&emsp;首先根据题意，最终要得到不同整数的最少数目，说明我们所删除的k个元素要尽可能的互不相同，也就是说优先删除出现次数最少的元素。<br>&emsp;&emsp;根据上述思路，这里我们选择使用map来完成&lt;数据, 出现次数&gt;的存储。然后通过按照出现次数递增的顺序进行删除即可。但是，map的有序性是指对key的排序，显然这里我们需要做的是对于map中的value排序。  </p><ul><li>方法一：使用map + vector实现对value的排序。  </li></ul><a id="more"></a><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> cmp(const pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;&amp; A, const pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;&amp; B)&#123; <span class="hljs-comment">//规定对于map元素中value的排序规则</span>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>second &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>second;   <span class="hljs-comment">// 按照second值从小到大排序</span>&#125;<span class="hljs-keyword">class</span> Solution &#123;public:    <span class="hljs-built_in">int</span> find<span class="hljs-constructor">LeastNumOfUniqueInts(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;        <span class="hljs-built_in">int</span> n = arr.size<span class="hljs-literal">()</span>;        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;        map&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; M;    <span class="hljs-comment">// 建立关于&lt;数据, 出现次数&gt;的映射关系</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>find(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-literal">()</span>)&#123;  <span class="hljs-comment">// 第一次出现</span>                M<span class="hljs-literal">[<span class="hljs-identifier">arr</span>[<span class="hljs-identifier">i</span>]</span>] = <span class="hljs-number">1</span>;                ans++;  <span class="hljs-comment">// ans用来记录不同数据的个数</span>            &#125;<span class="hljs-keyword">else</span>   M<span class="hljs-literal">[<span class="hljs-identifier">arr</span>[<span class="hljs-identifier">i</span>]</span>]++;        &#125;        vector&lt;pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; &gt; vec(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);    <span class="hljs-comment">// 将map中的内容转存到vector中</span>        sort(vec.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, vec.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, cmp);  <span class="hljs-comment">// 对线性的vector进行排序</span>        <span class="hljs-keyword">for</span>(auto it = vec.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>; it != vec.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>; it++)&#123;            k -= it-&gt;second;            <span class="hljs-keyword">if</span>(k &lt; <span class="hljs-number">0</span>)   break;  <span class="hljs-comment">// 如果减去所有出现的当前元素后，k&lt;0,则当前元素减不完</span>            <span class="hljs-keyword">if</span>(k<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;                ans--;                break;            &#125;            ans--;  <span class="hljs-comment">//从所有不同数据中减去当前数据</span>                    &#125;        return ans;    &#125;&#125;;</code></pre><ul><li>方法二：使用map + 优先队列实现对value的排序。(思路差不多，主要熟悉熟悉优先队列的使用）  </li></ul><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLeastNumOfUniqueInts</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)m[arr[i]]++;              <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : m)pq.push(&#123;x.second, x.first&#125;);        <span class="hljs-keyword">while</span>(k &amp;&amp; pq.<span class="hljs-built_in">size</span>()) &#123;          <span class="hljs-keyword">auto</span> t = pq.top();          <span class="hljs-keyword">if</span>(k &gt;= t.first)k -= t.first;          <span class="hljs-keyword">else</span><span class="hljs-keyword">break</span>;        &#125;        pq.pop();    &#125;    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">size</span>();&#125;;</code></pre><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li>时间复杂度：单层for循环，时间复杂度为O(n)。  </li><li>空间复杂度：map+vector或map+priority_queue，空间复杂度为O(n)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70.爬楼梯</title>
    <link href="/2020/06/13/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2020/06/13/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要n阶才能达到楼顶。<br>每次只能爬1阶或2阶。请问共有多少种不同的方法可以爬到楼顶？  </p><a id="more"></a><h3 id="思路与算法："><a href="#思路与算法：" class="headerlink" title="思路与算法："></a>思路与算法：</h3><p>我们用<code>dp[i]</code>来表示到第<code>i</code>阶的方案数，由于题目限制每次只能爬1阶或2阶，所以可以得到动态规划的转移方程：  </p><center> dp[i] = dp[i-1] + dp[i-2] </center>     <p>边界条件设置<code>dp[0] = 1, dp[1] = 1</code>。<br>由于每次计算只用到了第<code>i-1</code>阶和第<code>i-2</code>阶的数据，所以可以只设置三个变量来代替数组，从而降低空间复杂度。  </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;            p = q;            q = r;            r = p + q;        &#125;        <span class="hljs-keyword">return</span> r;    &#125;&#125;;   </code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：循环执行了n次，每次花费常数的时间代价，故时间复杂度为O(n)。  </li><li>空间复杂度：只用了常数个变量作为辅助空间，故空间复杂度为O(1)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
