

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Yeefine">
  <meta name="keywords" content="">
  <title>Servlet规范 - Yeefine&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Yeefine</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-03-21 22:15" pubdate>
      2021年3月21日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      69
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Servlet规范</h1>
            
            <div class="markdown-body" id="post-body">
              <h3 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h3><h4 id="一、Servlet规范介绍："><a href="#一、Servlet规范介绍：" class="headerlink" title="一、Servlet规范介绍："></a>一、Servlet规范介绍：</h4><ul>
<li>servlet规范来自于JAVAEE规范中的一种</li>
<li>作用：<ul>
<li>在Servlet规范中，指定【动态资源文件】开发步骤</li>
<li>在Servlet规范中，指定Http服务器调用动态资源文件规则</li>
<li>在Servlet规范中，指定Http服务器管理动态资源文件实例对象规则</li>
</ul>
</li>
</ul>
<h4 id="二、Servlet接口实现类："><a href="#二、Servlet接口实现类：" class="headerlink" title="二、Servlet接口实现类："></a>二、Servlet接口实现类：</h4><ul>
<li>Servlet接口是来自于Servlet规范下的一个接口，这个接口存在于Http服务器所提供的jar包中。</li>
<li>Tomcat服务器下lib文件有一个servlet-api.jar存放Servlet接口（javax.servlet.Servlet接口）。</li>
<li>Servlet规范中的认为，Http服务器能调用的【动态资源文件】必须是一个Servlet接口实现类。</li>
</ul>
<h4 id="三、Servlet接口实现类开发步骤"><a href="#三、Servlet接口实现类开发步骤" class="headerlink" title="三、Servlet接口实现类开发步骤"></a>三、Servlet接口实现类开发步骤</h4><ul>
<li><p>第一步：创建一个Java类继承于HttpServlet父类，使之成为一个Servlet接口实现类</p>
</li>
<li><p>第二步：重写HttpServlet父类中的两个方法。<code>doGet</code>或者<code>doPost</code></p>
</li>
<li><p>第三步：将Servlet接口实现类信息【注册】到Tomcat服务器</p>
<p>【网站】—-&gt;【Web】—-&gt;【WEB-INF】—-&gt; web.xml</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将Servlet接口实现类类路径地址交个Tomcat--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <span class="hljs-comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span> <span class="hljs-comment">&lt;!--声明servlet接口实现类类路径--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

Tomcat  String mm = &quot;com.bjpowernode.controller.OneServlet&quot;

<span class="hljs-comment">&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/one<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <span class="hljs-comment">&lt;!--设置简短请求别名，别名在书写时必须以&quot;/&quot;为开头--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>


如果现在浏览器向Tomcat索要OneServlet时地址
http://localhost:8080/myWeb/one</code></pre>
</li>
</ul>
<h4 id="四、Servlet对象生命周期："><a href="#四、Servlet对象生命周期：" class="headerlink" title="四、Servlet对象生命周期："></a>四、Servlet对象生命周期：</h4><ul>
<li><p>网站中所有的Servlet接口实现类的实例对象，只能由Http服务器负责创建。开发人员不能手动创建Servlet接口实现类的实例对象。</p>
</li>
<li><p>在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时，自动创建这个Servlet接口实现类的实例对象。</p>
<p>在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <span class="hljs-comment">&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bjpowernode.controller.OneServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span> <span class="hljs-comment">&lt;!--填写一个大于0的整数即可，默认值为0--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre>
</li>
<li><p>在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象</p>
</li>
<li><p>在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁</p>
</li>
</ul>
<h4 id="五、HttpServletResponse接口"><a href="#五、HttpServletResponse接口" class="headerlink" title="五、HttpServletResponse接口"></a>五、HttpServletResponse接口</h4><ul>
<li>介绍：<ul>
<li>HttpServletResponse接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar</li>
<li>HttpServletResponse接口实现类由Http服务器负责提供</li>
<li>HttpServletResponse接口负责将<code>doGet/doPost</code>方法执行结果写入到【响应体】交给浏览器</li>
<li>开发人员习惯于将HttpServletResponse接口修饰的对象称为【响应对象】</li>
</ul>
</li>
<li>主要功能：<ul>
<li>将执行结果以二进制形式写入到【响应体】</li>
<li>设置响应头中<code>content-type</code>属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】</li>
<li>设置响应头中【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求</li>
</ul>
</li>
</ul>
<h4 id="六、-HttpServletRequest接口"><a href="#六、-HttpServletRequest接口" class="headerlink" title="六、 HttpServletRequest接口"></a>六、 HttpServletRequest接口</h4><ul>
<li>介绍：<ul>
<li>HttpServletRequest接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar</li>
<li>HttpServletRequest接口实现类由Http服务器负责提供</li>
<li>HttpServletRequest接口负责在<code>doGet/doPost</code>方法运行时读取Http请求协议包中信息</li>
<li>开发人员习惯于将HttpServletRequest接口修饰的对象称为【请求对象】</li>
</ul>
</li>
<li>作用：<ul>
<li>可以读取Http请求协议包中【请求行】信息</li>
<li>可以读取保存在Http请求协议包中【请求头】或者【请求体】中请求参数信息</li>
<li>可以代替浏览器向Http服务器申请资源文件调用</li>
</ul>
</li>
</ul>
<h4 id="七、请求对象和响应对象生命周期"><a href="#七、请求对象和响应对象生命周期" class="headerlink" title="七、请求对象和响应对象生命周期"></a>七、请求对象和响应对象生命周期</h4><ul>
<li>在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】。</li>
<li>在Http服务器调用<code>doGet/doPost</code>方法时，负责将【请求对象】和【响应对象】作为实参传递到方，确保<code>doGet/doPost</code>正确执行。</li>
<li>在Http服务器准备推送Http相应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】销毁。</li>
</ul>
<p>【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中</p>
<p>【请求对象】和【响应对象】相当于用户在服务端的代言人</p>
<h4 id="八、欢迎资源文件"><a href="#八、欢迎资源文件" class="headerlink" title="八、欢迎资源文件"></a>八、欢迎资源文件</h4><ul>
<li><p>前提：用户可以记住网站名，但是不会记住网站资源文件名</p>
</li>
<li><p>默认欢迎资源文件：用户发送了一个针对某个网站的【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件</p>
<ul>
<li>正常请求：<code>http://localhost:8080/myWeb/index.html</code></li>
<li>默认请求：<code>http://localhost:8080/myWeb/</code></li>
</ul>
</li>
<li><p>Tomcat对于默认欢迎资源文件定位规则</p>
<ul>
<li><p>规则位置：Tomcat安装位置/conf/web.xml</p>
</li>
<li><p>规则命令：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>设置当前网站的默认欢迎资源文件规则</p>
<ul>
<li><p>规则位置：网站/Web/WEB-INF/web.xml</p>
</li>
<li><p>规则命令：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>login.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span></code></pre>
</li>
<li><p>网站设置自定义默认文件定位规则，此时Tomcat自带定位规则将失效</p>
</li>
</ul>
</li>
</ul>
<h4 id="九、Http状态码"><a href="#九、Http状态码" class="headerlink" title="九、Http状态码"></a>九、Http状态码</h4><ul>
<li><p>介绍：</p>
<ul>
<li><p>由三位数字组成的一个符号。</p>
</li>
<li><p>Http服务器在推送响应包之前，根据本次请求处理情况，将Http状态码写入到响应包中的【状态行】上</p>
</li>
<li><p>如果Http服务器针对本次请求，返回了对应的资源文件。通过Http状态码通知浏览器应该如何处理这个结果。</p>
<p>如果Http服务器针对本次请求，无法返回对应的资源文件。通过Http状态码向浏览器解释不能提供服务的原因。</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>组成：100——599 分为5个大类</p>
</li>
<li><p><code>1XX</code>：最有特征的是<code>100</code>，通知浏览器本次返回的资源文件，并不是一个独立的资源文件，需要浏览器在接受响应包之后，继续向Http服务器所要依赖的其他资源文件</p>
</li>
<li><p><code>2XX</code>：最有特征的是<code>200</code>，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要所要其他关联文件。</p>
</li>
<li><p><code>3XX</code>：最有特征的是<code>302</code>，通知浏览器本次返回的不是一个资源文件内容，而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件。</p>
<p><code>response.sendRedirect(&quot;资源文件地址&quot;)</code>写入到响应头中的<code>location</code>，而这个行为导致Tomcat将<code>302</code>状态码写入到状态行。</p>
</li>
<li><p><code>4XX</code>：</p>
<ul>
<li><code>404</code>：通知浏览器，由于在服务端没有定位到被访问的资源文件，因此无法提供帮助</li>
<li><code>405</code>：通知浏览器，在服务端已经定位到北方网的资源文件（Servlet），但是这个Servlet对于浏览器采用的请求方式不能处理。</li>
</ul>
</li>
<li><p><code>5XX</code>：</p>
<ul>
<li><code>500</code>：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet），这个Servlet可以接受浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="十、多个Servlet之间调用规则："><a href="#十、多个Servlet之间调用规则：" class="headerlink" title="十、多个Servlet之间调用规则："></a>十、多个Servlet之间调用规则：</h4><ul>
<li>前提条件：浏览器一次只能访问一个Servlet，某些来自于浏览器发送的请求，往往需要服务端中多个Servlet协同处理。</li>
<li>提高用户使用感受规则：无论本次请求涉及到多少个Servlet，用户只需要【手动】通知浏览器发起一次请求即可。</li>
<li>多个Servlet之间调用规则：<ul>
<li>重定向解决方案</li>
<li>请求转发解决方案</li>
</ul>
</li>
</ul>
<h4 id="十一、重定向解决方案"><a href="#十一、重定向解决方案" class="headerlink" title="十一、重定向解决方案"></a>十一、重定向解决方案</h4><ul>
<li><p>工作原理：用户第一次通过【手动方式】通知浏览器访问OneServlet。OneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将<code>302</code>状态码写入到状态行。</p>
<p>在浏览器接收到响应包之后，会读取到<code>302</code>状态。此时浏览器自动根据响应头中location属性地址发起第二次请求，访问TwoServlet去完成请求中剩余任务。</p>
</li>
<li><p>实现命令：<code>response.sendRedirect(&quot;请求地址&quot;)</code>，将地址写入到响应包中响应头中location属性</p>
</li>
<li><p>特征：</p>
<ul>
<li><p>请求地址：既可以把当前网站内部的资源文件地址发送给浏览器（/网站名/资源文件名）</p>
<p>也可以把其他网站资源文件地址发送给浏览器（<code>http://ip地址:端口号/网站名/资源文件名</code>）</p>
</li>
<li><p>请求次数：浏览器至少发送两次请求，但是只有第一次请求是用户手动发送。后续请求都是浏览器自动发送的。</p>
</li>
<li><p>请求方式：重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】。</p>
</li>
</ul>
</li>
<li><p>缺点：重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间。</p>
</li>
</ul>
<h4 id="十二、请求转发解决方案"><a href="#十二、请求转发解决方案" class="headerlink" title="十二、请求转发解决方案"></a>十二、请求转发解决方案</h4><ul>
<li><p>原理：用户第一次通过手动方式要求浏览器访问OneServlet。OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申请调用TwoServlet。Tomcat在接收到这个请求之后，自动调用TwoServlet来完成剩余任务。</p>
</li>
<li><p>实现命令：请求对象代替浏览器向Tomcat发送请求</p>
<pre><code class="hljs java"><span class="hljs-comment">// 1.通过当前请求对象生成资源文件申请报告对象</span>
	RequestDispatcher report = resquest.getRequestDispatcher(<span class="hljs-string">&quot;/资源文件名&quot;</span>);	<span class="hljs-comment">// 一定要以&quot;/&quot;为开头</span>
<span class="hljs-comment">// 2.将报告对象发送给Tomcat</span>
    report.forward(当前请求对象，当前响应对象);</code></pre>
</li>
<li><p>优点：</p>
<ul>
<li>无论本次请求涉及到多少个Servlet，用户只需要手动通过浏览器发送一次请求</li>
<li>Servlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数，增加处理服务速度。</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li><p>请求次数：在请求转发过程中，浏览器只发送一次请求</p>
</li>
<li><p>请求地址：只能向Tomcat服务器申请调用当前网站下资源文件地址</p>
<p><code>request.getRequestDispatcher(&quot;/资源文件名&quot;)</code>    <strong>不要写网站名</strong></p>
</li>
<li><p>请求方式：在请求转发过程中，浏览器只发送了一个Http请求协议包。参与本次请求的所有Servlet共享同一个请求协议包，因此这些Servlet接受的请求方式与浏览器发送的请求方式保持一致。</p>
</li>
</ul>
</li>
</ul>
<h4 id="十三、多个Servlet之间数据共享实现方案"><a href="#十三、多个Servlet之间数据共享实现方案" class="headerlink" title="十三、多个Servlet之间数据共享实现方案"></a>十三、多个Servlet之间数据共享实现方案</h4><ul>
<li>数据共享：OneServlet工作完毕后，将产生数据交个TwoServlet来使用</li>
<li>Servlet规范中提供四种数据共享方案<ul>
<li><code>ServletContext</code>接口</li>
<li><code>Cookie</code>接口</li>
<li><code>HttpSession</code>接口</li>
<li><code>HttpServletRequest</code>接口</li>
</ul>
</li>
</ul>
<h4 id="十四、ServletContext接口"><a href="#十四、ServletContext接口" class="headerlink" title="十四、ServletContext接口"></a>十四、ServletContext接口</h4><ul>
<li><p>介绍：</p>
<ul>
<li>来自于Servlet规范中一个接口。在Tomcat中存在servlet-api.jar。在Tomcat中负责提供这个接口实现类</li>
<li>如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享</li>
<li>开发人员习惯于将ServletContext对象称为【全局作用域对象】</li>
</ul>
</li>
<li><p>工作原理：每一个网站都存在一个全局作用域对象。这个全局作用域对象【相当于】一个Map。在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用。</p>
</li>
<li><p>全局作用域对象生命周期：</p>
<ul>
<li>在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象</li>
<li>在Http服务器运行期间，一个网站只有一个全局作用域对象</li>
<li>在Http服务器运行期间，全局作用域对象一直处于存活状态</li>
<li>在Http服务器准备关闭时，负责将当前网站中全局作用域对象进行销毁处理</li>
</ul>
<p><strong>全局作用域对象生命周期贯穿网站整个运行期间</strong></p>
</li>
<li><p>实现命令：【同一个网站】OneServlet将数据共享给TwoServlet</p>
<pre><code class="hljs java">OneServlet &#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
		<span class="hljs-comment">// 1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】</span>
		ServletContext application = request.getServletContext();
		<span class="hljs-comment">// 2.将数据添加到全局作用域对象作为【共享数据】</span>
		application.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, 数据);
	&#125;
&#125;

TwoServlet &#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
		<span class="hljs-comment">// 1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】</span>
		ServletContext application = request.getServletContext();
		<span class="hljs-comment">// 2.从全局作用域对象得到指定关键字对应数据</span>
		Object 数据 = application.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);
	&#125;
&#125;

</code></pre>
</li>
</ul>
<h4 id="十五、Cookie"><a href="#十五、Cookie" class="headerlink" title="十五、Cookie"></a>十五、Cookie</h4><ul>
<li><p>介绍：</p>
<ul>
<li>Cookie来自于Servlet规范中一个工具类，存在于Tomcat所提供的servlet-api.jar中</li>
<li>如果两个Servlet来自于同一个网站，并且为同一个浏览器、用户提供服务，此时借助于Cookie对象进行数据共享</li>
<li>Cookie存放当前用户的私人数据，在共享数据过程中提高服务质量</li>
</ul>
</li>
<li><p>原理：</p>
<p>用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。OneServlet在运行期间创建一个Cookie存储与当前用户相关的数据。OneServlet工作完毕后，【将Cookie写入到响应头】交还给当前浏览器。</p>
<p>浏览器收到响应协议包之后，将cookie存储在浏览器的缓存一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时，【浏览器需要无条件的将myWeb网站之前推送过来的cookie，写入到请求头】发送过去。</p>
<p>此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据</p>
</li>
<li><p>实现命令：同一个网站 OneServlet 与 TwoServlet 借助于Cookie实现数据共享</p>
<pre><code class="hljs java">OneServlet &#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
        <span class="hljs-comment">// 1.创建一个cookie对象，保存共享数据（当前用户数据）</span>
        Cookie card = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>);
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">        	cookie相当于一个map</span>
<span class="hljs-comment">        	一个cookie中只能存放一个键值对</span>
<span class="hljs-comment">        	这个键值对的key与value只能是String</span>
<span class="hljs-comment">        	键值对中key不能是中文</span>
<span class="hljs-comment">        */</span>
        <span class="hljs-comment">// 2.将cookie写入到响应头，交给浏览器</span>
        response.addCookie(card);
    &#125;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">	浏览器/用户	&lt;----------响应包 【200】</span>
<span class="hljs-comment">						        【cookie: key1=abc】</span>
<span class="hljs-comment">								【】</span>
<span class="hljs-comment">								【处理结果】</span>
<span class="hljs-comment">	</span>
<span class="hljs-comment">	浏览器向myWeb网站发送请求访问TwoServlet ----&gt; 请求包【url:/myWeb/two method:get】</span>
<span class="hljs-comment">												   【</span>
<span class="hljs-comment">												   		请求参数:xxxx</span>
<span class="hljs-comment">												   		Cookie  key1=abc</span>
<span class="hljs-comment">												   】</span>
<span class="hljs-comment">												   【】</span>
<span class="hljs-comment">												   【】</span>
<span class="hljs-comment">*/</span>

TwoServlet&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
        <span class="hljs-comment">// 1.调用请求对象从请求头得到浏览器返回的Cookie</span>
        Cookie[] cookieArray = request.getCookies();
        <span class="hljs-comment">// 2.循环遍历数据得到每一个cookie的key与value</span>
        <span class="hljs-keyword">for</span> (Cookie card : cookieArray) &#123;
            String key = card.getName();	<span class="hljs-comment">// 读取key  &quot;key1&quot;</span>
            String value = card.getValue();	<span class="hljs-comment">// 读取value &quot;abc&quot;</span>
            提供较好的服务。。。
        &#125;
    &#125; 
&#125;
</code></pre>
</li>
<li><p>Cookie销毁时机：</p>
<ul>
<li>在默认情况下，Cookie对象存放在浏览器的缓存中，因此只要浏览器关闭，Cookie对象就被销毁掉</li>
<li>在手动设置情况下，可以要求浏览器将接受的Cookie存放在客户端计算机上的硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器或关闭客户端计算，关闭服务器，都不会导致Cookie被销毁。在存活时间到达时，Cookie自动从硬盘上被删除。</li>
<li><code>cookie.setMaxAge(60);   // cookie在硬盘上存活1分钟</code></li>
</ul>
</li>
</ul>
<h4 id="十六、HttpSession接口"><a href="#十六、HttpSession接口" class="headerlink" title="十六、HttpSession接口"></a>十六、HttpSession接口</h4><ul>
<li><p>介绍：</p>
<ul>
<li>HttpSession接口来自于Servlet规范下的一个接口。存在于Tomcat中servlet-api.jar。其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar</li>
<li>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享。</li>
<li>开发人员习惯于将HttpSession接口修饰对象称为【会话作用域对象】</li>
</ul>
</li>
<li><p>HttpSession与Cookie区别：【面试题】</p>
<ul>
<li>存储位置：一个在天上，一个在地下<ul>
<li>Cookie：存放在客户端计算机（浏览器内存/硬盘）</li>
<li>HttpSession：存放在服务端计算机内存</li>
</ul>
</li>
<li>数据类型：<ul>
<li>Cookie：存储的共享数据类型只能是String。</li>
<li>HttpSession：可以存储任意类型的共享数据Object</li>
</ul>
</li>
<li>数据数量：<ul>
<li>Cookie：一个Cookie对象只能存储一个共享数据</li>
<li>HttpSession：使用map集合存储共享数据，所以可以存储任意数量共享数据</li>
</ul>
</li>
<li>参照物：<ul>
<li>Cookie：相当于客户端在服务端的【会员卡】</li>
<li>HttpSession：相当于客户在服务端的【私人保险柜】</li>
</ul>
</li>
</ul>
</li>
<li><p>命令实现：同一个网站下OneServlet将数据传递给TwoServlet</p>
<pre><code class="hljs java">OneServlet &#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
        <span class="hljs-comment">// 1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span>
        HttpSession session = request.getSession();
        <span class="hljs-comment">// 2.将数据添加到用户私人储物柜</span>
        session.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, 共享数据);
    &#125;
&#125;

<span class="hljs-comment">// 浏览器访问/myWeb中TwoServlet</span>
TwoServlet &#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
        <span class="hljs-comment">// 1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜</span>
        HttpSession session = request.getSession();
        <span class="hljs-comment">// 2.从会话作用域对象得到OneServlet提供的共享数据</span>
        Object 共享数据 = session.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Http服务器如何将用户与HttpSession关联起来：Cookie</p>
</li>
<li><p>getSession() 与 getSession(false)</p>
<ul>
<li><code>getSession()</code>：如果当前用户在服务端已经拥有了自己的私人储物柜，要求Tomcat将这个私人储物柜进行返回；如果当前用户在服务端尚未拥有自己的私人储物柜，要求tomcat为当前用户创建一个全新的私人储物柜。</li>
<li><code>getSession(false)</code>：如果当前用户在服务端已经拥有了自己的私人储物柜，要求tomcat将这个私人储物柜进行返回；如果当前用户在服务端尚未拥有自己的私人储物柜，此时Tomcat将返回<code>null</code>。</li>
</ul>
</li>
<li><p>HttpSession销毁时机</p>
<ul>
<li>用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中。</li>
<li>在浏览器关闭时，意味着用户与它的HttpSession关系被切断。</li>
<li>由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会导致Tomcat将浏览器关联的HttpSession进行销毁。</li>
<li>为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】。这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟。此时Tomcat认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁掉这个HttpSession。</li>
</ul>
</li>
<li><p>HttpSession空闲时间手动设置</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前网站/web/WEB-INF/web.xml--&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span>	<span class="hljs-comment">&lt;!--当前网站中每一个session最大空闲时间5分钟--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre>
</li>
</ul>
<h4 id="十七、HttpServletRequest接口实现数据共享"><a href="#十七、HttpServletRequest接口实现数据共享" class="headerlink" title="十七、HttpServletRequest接口实现数据共享"></a>十七、HttpServletRequest接口实现数据共享</h4><ul>
<li><p>介绍：</p>
<ul>
<li>在同一个网站中，如果两个servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。 而一个请求协议包只对应一个请求对象，因此servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个Servlet之间实现数据共享。</li>
<li>在请求对象实现Servlet之间数据共享功能时，开发人员将请求对象称为【请求作用域对象】。</li>
</ul>
</li>
<li><p>实现命令：OneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据</p>
<pre><code class="hljs java">OneServlet &#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
       	<span class="hljs-comment">// 1.将数据添加到【请求作用域对象】中attribute属性</span>
        request.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, 数据);	<span class="hljs-comment">// 数据类型可以任意类型Object</span>
        <span class="hljs-comment">// 2.向Tomcat申请调用TwoServlet</span>
        request.getRequestDispatcher(<span class="hljs-string">&quot;/two&quot;</span>).forward(request, response);
    &#125;
&#125;

TwoServlet &#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;
    	<span class="hljs-comment">// 从当前请求对象得到OneServlet写入到共享数据</span>
        Object 数据 = request.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);
    &#125;
&#125;</code></pre>
</li>
</ul>
<h4 id="十八、Servlet规范扩展-——-监听器接口"><a href="#十八、Servlet规范扩展-——-监听器接口" class="headerlink" title="十八、Servlet规范扩展 —— 监听器接口"></a>十八、Servlet规范扩展 —— 监听器接口</h4><ul>
<li>介绍：<ul>
<li>一组来自于Servlet规范下的接口，共有8个接口。存在于Tomcat所提供的servlet-api.jar包</li>
<li>监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类</li>
<li>监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】</li>
</ul>
</li>
<li><p>作用域对象：</p>
<ul>
<li>在Servlet规范中，认为在服务端内存中，可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】</li>
<li>Servlet规范下的作用域对象：<ul>
<li><code>ServletContext</code>：全局作用域对象</li>
<li><code>HttpSession</code>：会话作用域对象</li>
<li><code>HttpServletRequest</code>：请求作用域对象</li>
</ul>
</li>
</ul>
</li>
<li><p>将挺起接口实现类开发规范：三步</p>
<ul>
<li>根据监听的实际情况，选择对应监听器接口进行实现</li>
<li>重写监听器接口声明【监听事件处理方法】</li>
<li>在web.xml文件将监听器接口实现类注册到Http服务器</li>
</ul>
</li>
<li><p><code>ServletContextListener</code>接口：</p>
<ul>
<li>作用：通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻</li>
<li>监听事件处理方法：<ul>
<li><code>public void contextInitlized()</code>：在全局作用域对象被Http服务器初始化时被调用</li>
<li><code>public void contextDestory()</code>：在全局作用域对象被Http服务器销毁时触发调用</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ServletContextAttributeListener</code>接口：</p>
<ul>
<li>作用：通过这个接口合法的检测全局作用域对象中的共享数据的变化时刻</li>
<li>监听事件处理方法：<ul>
<li><code>public void contextAdd()</code>：在全局作用域对象添加共享数据时</li>
<li><code>public void contextReplaced()</code>：在全局作用域对象更新共享数据时</li>
<li><code>public void contextRemove()</code>：在全局作用域对象删除共享数据时</li>
</ul>
</li>
</ul>
</li>
<li>全局作用域对象共享数据变化时刻</li>
</ul>
<h4 id="十九、Servlet规范扩展——Filter接口（过滤器接口）"><a href="#十九、Servlet规范扩展——Filter接口（过滤器接口）" class="headerlink" title="十九、Servlet规范扩展——Filter接口（过滤器接口）"></a>十九、Servlet规范扩展——Filter接口（过滤器接口）</h4><ul>
<li><p>介绍：</p>
<ul>
<li>来自于Servlet规范下的接口，在Tomcat中存在于servlet-api.jar包</li>
<li>Filter接口实现类由开发人员负责提供，Http服务器不负责提供</li>
<li>Filter接口在Http服务器调用资源文件之前，对Http服务器进行拦截</li>
</ul>
</li>
<li><p>具体作用：</p>
<ul>
<li>拦截Http服务器，帮助Http服务器检测当前请求合法性</li>
<li>拦截Http服务器，对当前请求进行增强操作</li>
</ul>
</li>
<li><p>Filter接口实现类开发步骤：三步</p>
<ul>
<li>创建一个Java类实现Filter接口</li>
<li>重写Filter接口中doFilter方法</li>
<li>web.xml将过滤器接口实现类注册到Http服务器</li>
</ul>
</li>
<li><p>Filter拦截地址格式：</p>
<ul>
<li><p>命令格式：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>oneFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>拦截地址<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>
</code></pre>
</li>
<li><p>命令作用：拦截地址通知Tomcat在调用何种资源文件之前需要调用OneFilter过滤进行拦截</p>
</li>
<li><p>要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截</p>
<p><code>&lt;url-pattern&gt;/img/test.jpg&lt;/url-pattern&gt;</code></p>
</li>
<li><p>要求Tomcat在调用某一个文件夹下所有资源文件之前，来调用OneFilter拦截</p>
<p><code>&lt;url-pattern&gt;/img/*&lt;/url-pattern&gt;</code></p>
</li>
<li><p>要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截</p>
<p><code>&lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;</code></p>
</li>
<li><p>要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截</p>
<p><code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code></p>
</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%80%BB%E7%BB%93/">总结</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JavaWeb/">JavaWeb</a>
                    
                      <a class="hover-with-bg" href="/tags/Servlet/">Servlet</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/26/JSP%E5%B0%8F%E7%BB%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JSP小结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/21/Http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85/">
                        <span class="hidden-mobile">Http网络协议包</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Servlet规范&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
